<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<meta name="description" content="A description of EEBench an open source, open access low cost
   oscilloscope and arbitrary waveform generator based on FPGA BASYS3 and nodejs JavaScript" />
<html xml:lang="en" lang="en" xmlns="http://www.w3.org/1999/xhtml">
<title> AWG Arbitrary Waveform Generator NodeEEBench </title>
<head>

<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link rel="stylesheet" type="text/css" href="../css/style.css" media="all" />
 <style>
.imgcon {width: 525px; margin: 0 auto; padding: 0; text-align: center;}
#anim {width: 270px; height: 320px; position: relative; margin-top: 0.5em;}
#anim img {position: absolute; top: 42px; left: 24px;}
img#me01 {top: 0; left: 0;}
img#me02 {left: 23px;}
img#me04 {top: 44px;}
img#me05 {top: 43px;left: 36px;}
div.scrollX {
  width: 400px;
  height: 200px;
  overflow: scroll;
}
th.norm {
    background-color: #CCCCCC;
    color: black;
} 
table.norm, th.norm, td.norm {
   border-collapse: collapse;
   border: 1px solid black;
}
th.clr {
} 
</style> 

<!-- Prettify Google -->
<link href="../google-code-prettify/src/prettify.css" type="text/css" rel="stylesheet" />
<script type="text/javascript" src="../google-code-prettify/src/prettify.js"></script>
<script type="text/javascript" src="../google-code-prettify/src/lang-vhdl.js"></script>
<!-- Chart -->
<SCRIPT SRC="../Chart_2013_03_11/Chart_basic.js"></SCRIPT>
<!-- JQuery -->
<script type="text/javascript" src="../scripts/jquery.js"></script>
<!-- LTSPICE -->
<SCRIPT SRC="../SPICE_HTML_2018_02/LTSPICE.js"></SCRIPT>
<!-- QR Code -->
<script src="../QRCode/jsqr-1.0.2.js" type="text/javascript"></script>
<!-- Usage Logging -->
<SCRIPT SRC="../scripts/ToggleLog.js"></SCRIPT>
<!-- MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
    tex2jax: {inlineMath: [["$$","$$"],["\\(","\\)"]]}
  });
</script>
<script type="text/javascript" src="../MathJax/MathJax.js"></script>

</head>
<body>
<!--
  BEGIN: Content of extension "ts_mit", plugin "tx_tsmit_pi1"
 -->
  <div id="headx">
  <div id="nheader1" style="background-color:#0067a5;color:#FFFFFF" align="right" >
     <a href="https://www.hochschule-kempten.de" style="color:#FFFFFF"> Hochschule Kempten &nbsp; &nbsp; &nbsp; </a>
  </div>
  <div id="nheader2" style="background-color:#05adb5;color:#FFFFFF" align="right" >
     <a href="https://www.hs-kempten.de/fakultaet-elektrotechnik/" style="color:#FFFFFF">
	 Fakultät Elektrotechnik &nbsp; &nbsp; &nbsp;
  </div>
  <div id="nheader3" style="background-color:#f18700;color:#FFFFFF" align="right">
     <a href="../Vollrath_Work.html" style="background-color:#f18700;color:#FFFFFF"> 
	 Publications &nbsp; &nbsp; &nbsp;</a>
     <a href="https://www.hs-kempten.de/elektrotechnik/fakultaet/personen-detailansicht/joerg-vollrath?tx_hisconnect_personenlisting%5Bbacklink%5D=607&cHash=effe2c6873f6c8a9f79b55b636d3bde2" style="background-color:#f18700;color:#FFFFFF"> 
	 Fachgebiet Elektronik, Prof. Vollrath &nbsp; &nbsp; &nbsp;</a>
  </div>
  </div>
<br>
<div> 
<table>
<tr><td style="width:70%">
  <h1>Timing of Arbitrary Waveform Generator with respect to OSC and FFT in NodeEEBench</h1>

Jörg Vollrath, University of Applied Science Kempten, Germany, Joerg.vollrath@hs-kempten.de<br>
August, 2025<br>
<br>
<hr>
<br>
<img src="ImagesS/TimingBasics.png" width="600"><br>
Figure: Timing basics<br>

<h2> Overview</h2><br>

Arbritrary waveform generator and oscilloscope map voltage and frequency to positive integer digital 
values and sampling rates for ADC and DAC.<br> 
Correct timing control of the system is difficult due to different ADC and DAC sampling rates 
and oscilloscope time base and buffer size. FFT without bleeding requires an odd number of cycles,
making it necessary to adjust the chosen frequency.<br>
The software has to be adapted to the hardware requirements at the ADC, DAC control, the server side 
simulation and the client user interface.<br>
This document covers the implementation and test.<br>

<h3>To Do List</h3>
<ul>
<li>Verify lookup table: FPGA, Arduino, Simulation (Implementation not yet done) </li>
<li>MCP6022 Opamp with higher gain for frequency &gt; 30 kHz can extend FPGA R2R bandwidth?<br>
<li>Implement sawtooth (Counter) and noise waveform</li>
<li>Implement second generator and VP1, VP2 power supply</li>
</ul>


<h3>Done List</h3>
<ul>
<li>Arduino frequency and level working</li>
<li>FPGA, Arduino, Simulation working</li>
<li>Test Flow with example implemented (Section General Test)</li>
</ul>

<br>
<hr>
<br>

</td><td style="width:30%">  
<canvas id="thisQR"></canvas></td>
</tr>
</table>

<h2>Task</h2><br>

Voltage range has to be mapped to integer values for the DAC. Sample rates of DAC and ADC have to be synchronized. 
Frequency has to be adapted to give an integer odd number of cycles for a selected number of power of 2 points to 
get a non bleeding FFT.<br>
<br>  
This document explains how to generate waveforms (sine, triangle, rectangle) taking into account 
DAC sample rate, voltage range and ADC (Oscilloscope) voltage range, sample rate, time base and number of samples.<br>
It shows the communication interface and implementation in embedded hardware (FPGA, Arduino, Raspberry Pi), 
server (nodejs) and client (html, js).<br> 
<br>
The interface (serial commands) was optimized for the FPGA to simplify communication (single letter command identification) 
and minimize FPGA sine calculations. The other systems can be more easily adapted to this scheme.<br>
<br>
In the FPGA ADC and DAC have own hardware running parallel. In the other systems software controls serially 
the operation of ADC and DAC.<br>
<br>
The DAC should have a higher sampling rate than the ADC and should run at maximum sampling rate.<br>
The ADC runs for large block sizes and low time Base at high speed. For larger time Bases averaging can be done.<br>

<h4>ADC sampling rate reduction example</h4><br>

With a ADC sample rate of tosc = 8.32 us, a block size of 256 of dataMax=512 samples and a time base of tb = 200 us/div 
and 10 display divisions the oscilloscope measurement time tm should be: <br>
tm = 2 * 10 * tb = 4 ms<br>
To implement triggering 512 samples are taken and then a search for a trigger condition is done to give 256 triggered values.<br>
The needed sampling time tsx is:<br>
tsx = tm / dataMax = 8 us<br>
The maximum sampling rate tosc can be used.<br>
Choosing a smaller blocksize dataMax or larger time base tb gives larger sampling times tsx.<br>
ADC sampling is done a lower frequencies.<br>
This is calculated a the client side (Projekte/NEEBench.html, timeBase) and communicated via the O command.<br>  
<br>

<h2>Variables</h2><br><!------------------------------------------------------------->

The following properties are implemented at the client side as variables (Project/NEEBench.html) and 
input fields or select boxes with an id. 
The server (ServerEEBench.js) implements the variables for simulations and
the hardware implements variables for ADC and DAC control (Xilinx/.., Arduino/EEBench/..). The variables are communicated via
commands send via serial interface or websocket communication<br>
<br>
<h3>Property list</h3><br>
DAC sample rate tsDAC, DAC resolution, DAC positive output voltage range<br>
ADC sample rate tsADC, ADC resolution, ADC positive input voltage range<br>
AWG frequency<br>
OSC time base, OSC block size<br>
<br>
<table border="1">
<tr><td></td><td>Serial command</td><td>FPGA hardware,software</td><td>Arduino hardware,software</td>
    <td>Server Simulation</td><td>Client function, variable, id</td></tr>
<tr><td>DAC sample rate</td><td>"S","T"</td><td>10 ns</td><td>430 us </td><td>1 us</td><td>"AWG1tsVal"</td></tr>
<tr><td>DAC resolution</td><td>"S","T"</td><td>16 (R2R DAC)</td><td>12</td><td>16</td><td>"AWG1ResVal"</td></tr>
<tr><td>ADC sample rate</td><td>"O"</td><td>8.32 us</td><td>430 us</td><td>1 us</td><td>"timeSampling"</td></tr>
<tr><td>ADC resolution</td><td></td><td>12</td><td>12</td><td>12 </td><td></td></tr>
<tr><td>AWG frequency</td><td>"S","T"</td><td></td><td></td><td></td><td>genCmdAWG()</td></tr>
<tr><td>OSC time base</td><td>"O"</td><td></td><td></td><td></td><td>confOsc() "baseVal"</td></tr>
<tr><td>OSC block size</td><td>"O"</td><td></td><td></td><td></td><td>"dataMax"</td></tr>
</table>
<br>
The graphics shows all timing values not to scale to generate the oscilloscope picture.<br>
<br>
<img src="ImagesS/TimingBasics.png" width="600"><br>
Figure: Oscilloscope timing basics<br>
<br>
Using these values an integer number of periods for a sine FFT can be calculated:<br>
Input: timeBase, tsADC(ts), dataMax, frequency, tsDAC<br>
Intermediate: test time (tm), integer odd number of cycles (nCycle), frequency1<br>
Output: step<br>

<!---------------------------------------------------------------------->
<h2>Sine Waveform Serial Command and Calculation</h2><br>

A "S" command is used as described on the web page.<br>
S&lt;step&gt;&lt;amplitude&gt;&lt;offset&gt;<br>
Example f = 1 kHz, amp = 1 V, offset = 1 V as shown in AWG1: S0000A7C526C9B26C26C9B26C<br>
step = 0000A7C5, amplitude = 26C9B26C, offset = 26C9B26C<br>
<br>
First the appropriate hardware control is documented and then the corresponding 
client implementation to generate the 'S' command.<br>

<!---------------------------------------------------------------------->
<h3>BASYS3 VHDL code (Xilinx)</h3>

<pre>
entity sineX is
   Port (
       CLK : in STD_LOGIC;
       RST: in STD_LOGIC;
       step: in STD_LOGIC_Vector(31 downto 0);   -- increment
       amplitude: in STD_LOGIC_Vector(31 downto 0);   -- signal amplitude
       offset: in STD_LOGIC_Vector(31 downto 0);   -- signal offset
       mySine: out STD_LOGIC_Vector(31 downto 0) 
   );
end sineX;
</pre>
From 'step' (in degree) a real and imaginary part (StepRe, StepIm) are calculated for 
complex calculation of next complex sine value (X):<br>
<u>X</u><sub>i+1</sub> = <u>X</u><sub>i</sub> &middot; <u>Step</u>  <br>
<br>
Maximum 32-Bit value: 0x40000000 = 1024 * 1024 * 1024<br>
<br>
Based on FPGA R2R output range from 0 V to 3.3 V with 16-Bit and a sample frequency of 100MHz (T=10ns).<br>
Frequencies: 1 MHz to 500 Hz shows f3dB = 30 kHz low pass for 16-Bit R2R with MCP6022 rail-to-rail OpAmp<br>
Investigate: Increase gain of MCP6022 for frequencies above f3dB to extend R2R range from 30 kHz to ??? Hz. GBW MCP6022<br>
<br>

<!---------------------------------------------------------------------->
<h3>Sine Arduino (Arduino/EEBench/EEBench.ino)</h3><br>

The Arduino loop looks first for a command.
With no command Analog values are generated for sine and triangle 
using a stepIndex in the range from 0 up to 4095 for sine signal.<br>
The active value is then written to the internal ADC, PMOD AD2 and R2R DAC.<br>
Then  ADC values are read from internal ADC 0,1,2 and PMOD AD2 and stored in bufVal[bufIndex].<br>
cntV is incremented and data is sent if cntV = bufSize.<br>
ADC and DAC sampling is always done with maximum sampling rate.<br>
timeBase could be used to reduce ADC sample rate.<br>
<br>
<pre>
  stepS = hexToDec(myString.substring(1,7)); // 24 bit, 6 hex; from 32 bit value, 8 hex 
  ampS = hexToDec(myString.substring(9,13))/8; // 12 bit, 3 hex; from 32 bit value, 8 hex    
  offS = hexToDec(myString.substring(17,21))/8; // 12 bit, 3 hex; from 32 bit value, 8 hex 

  // Generate Analog value sine stepS range integer mapped to 0..1 by / 16 M
  awgX = (int)(offS) + (int)(ampS) * sin( TWO_PI * stepIndex * stepS / 1024 /1024 / 16 ); 
</pre>
At the moment the sample time is 480 us.<br>
Maximum samples in the buffer can be 2048.<br>
<br>
Tmax = 1024 * 480 us = 480 ms; fmin = 2 Hz<br>
Tmin8 = 8 * 480 us = 3.84 ms; f8max = 250 Hz<br>
Tmin4 = 4 * 480 us = 1.92 ms; f4max = 500 Hz<br>
Tmin2 = 2 * 480 us = 960 us; f2max = 1 kHz<br>
<br> 

<!---------------------------------------------------------------------->
<h3>Sine Simulation (ServerEEBench.js)</h3><br>

Simulation combines generation and acquisition in a nested loop.<br>
An odd or prime integer number of periods generates non bleeding FFT.<br>
Client calculation and server calculation are matched.<br>
<br>
(1) Step calculation (client, NodeEEBench.html) should be based on frequency (AWG) and
integer number of periods.<br>
The integer number of periods needs the total measurement time and modifies the frequency.<br>
<br>
function confOSC()<br>
The number of averaging (timeBase) of ADC samples is calculated by dividing the measurement time
tmeasure = baseVal * 20 by the block size (dataMax) times the ADC sampling time ("timeSampling").<br>
<pre>
timeBase = Math.round(unitToValue(document.getElementById("baseVal").value) * 20 
           / dataMax / unitToValue(document.getElementById("timeSampling").value));			 
</pre>
						 Since this can generate a timeBase of 0, which is difficult to handle at the FPGA side, 
timeBase + 1 is sent via serial communication.<br>
<pre>
     cmdO += decToHex((timeBase + 1),4);   // Sampling next FPGA 0 and 1 same!
</pre>
function genCmdAWG()<br>
First the correct timeBaseX is calculated. Then the total test time tm from the ADC sample
rate ts, the timeBaseX and the number of samples data / Max / 2.<br>
An odd integer number of cycles is set nCycle and a corrected frequency1 determined.<br>
This gives finally the correct step size.
<pre>
     var timeBaseX = timeBase;
     if (timeBaseX == 0) timeBaseX += 1;
     var tm = ts * timeBaseX * dataMax / 2 ;             // displayed measurement time tm    
     nCycle =  tm * frequency;                           //  
     if ( nCycle &gt;= 1) { 
       nCycle = Math.round(nCycle);
       if (nCycle % 2 == 0) nCycle = nCycle + 1;
     }
     frequency1 = nCycle / tm;   // fix integer cycles
     step = Math.trunc( tsDAC *  frequency1 * 1024 * 1024 * 1024 * 4 ); // range 0..1
</pre>
(2) Sine calculation (server, ServerEEbench.js) corrects the timeBase (mulTime), takes into account the step (step)
  and the ratio of tsADC/tsDAC (ratio).<br>
<pre>
     if (mulTime > 1) { mulTime -= 1; }

     for (var i = 0; i &lt; blockSize; i ++) {   // only sampling
       for (var j = 0; j &lt; ratio * mulTime; j ++) { // generate all points for DAC
         var timeX = 2 * Math.PI * (i * ratio * mulTime + j) * step / 1024 / 1024 / 1024 / 4 ;
         voltageC1 = Math.round(offset + amplitude * Math.sin(timeX)); // 
       }
     }		 
</pre>
(3) Time step calculation (client, NodeEEBench.html) should be based on (OSC, Time Base).
<pre>
     if (timeBase == 0) { timestep = timeSampling * (timeBase + 1);  //
     } else {timestep = timeSampling * timeBase; } 				   
</pre>	
6.08.2025: Test AWG1 simulation with frequency of 20 Hz, 100 Hz, 1 kHz and  Amplitude 0.4 V, 
Offset 0.5 V, OSC TimeBase 100 us/div, 2 ms/div, 10 ms/div, 100 ms/div and 
block size of (256 of 512), (1024 of 2048) and (4096 of 8192) showed good signals and FFTs.<br>
Some bleeding can be seen for low time base and very high time base.<br>
<br>
<!---------------------------------------------------------------------->
<h3>Sine AWG (NodeEEBench.html)</h3><br>

The sine generator is synchronized to the acquisition to allow a FFT without bleeding.<br>

<table>
<tr><td>Time Base</td><td>100 us/div </td><td>200 us/div </td><td>500 us/div </td><td>1 ms/div </td><td>2 ms/div </td></tr>
<tr><td>timeBase</td><td>1</td><td>2</td><td>4</td><td>6</td><td>10</td></tr>
</table>

The oscilloscope has a 'baseVal' (example: 200 us/div). This gives a display of 10 * baseVal.<br>
 timeBase = 'baseVal'/200E-6<br> 
 var timeX = (timeBase + 1)/4;<br> 
There are dataMax/2 sampled points displayed and should contain an odd/prime number of sine periods.<br>
There are nSample DAC samples (tSD) per ADC sample (tSA).<br>
 nSample = tSA/tSD<br>
The frequency for each sine sample calculation is<br>
 fCalc = 10 ns = 1E-8<br>
The signal frequency comes from id="frequencyVal" and is stored in frequency.<br>
 frequency = "frequencyVal"<br>
<br>
Maximum sine frequency should have 8 points (2 Shannon) per period to make a nice picture.<br>
fmax = 1 / tSD / 8<br>
Minimum sine frequency is limited by the step size.<br>
fmin = 1 / tsd / stepS<br>  

<pre>
function genCmdAWG() {
  var boardX = parseInt(document.getElementById("board").value);
  if (boardX == 0) {
         // document.getElementById("timeSampling").value = 8.32E-6;
         nSample = 13 * 128; // 8.32us / 10 ns * 2 FGA = Math.trunc(8.32E-6/10E-9*2) 
         maxC = 32767;
  } else if (boardX == 2) {
         // document.getElementById("timeSampling").value = 360E-6;
         nSample = 72000 * 3;  // 360us / 10 ns * 2 Arduino Maker WiFi = Math.trunc(360E-6/10E-9 * 2 * 3) 
         maxC = 4095;
  }
	   cmd = "S"; // Sine
	   ampC = Math.trunc( (2*1024*1024*1024-1) / maxV * amp); // Range 0.. 2^30
       offC = Math.trunc( (2*1024*1024*1024-1) / maxV * off);
       if (offC >= 2*1024*1024*1024) { offC = 2*1024*1024*1024-1; }
	   if ((offC + ampC) >= 2*1024*1024*1024) { ampC = 2*1024*1024*1024-1-offC; } 	   
	   if ((offC - ampC) < 0) { ampC = offC; }
	   // correct step with better frequency for good fft
	   // timeBase = 4 fft good 256 samples, 1 ms/div time base oscilloscope
	   var timeX = (timeBase + 1)/4;     // For slow timeBase sampling gets slower  
	   // fix nCycle to odd (prime)
	   // Measurement Time: Buffer size(dataMax) * sample time OSC(1/fCalc) * sample frequency(timeX,timeBase) 
	   //                         * nSample(Dac outputs per OSC sample)
       // Cycle Time: 1/frequency	   
	   var nCycle = dataMax / fCalc * timeX * nSample * frequency; // number of cycles
	   if (nCycle > 1) {   // Can only fix frequencies with more than 1 cycle
	     nCycle = Math.round(nCycle);
	     if ((nCycle % 2) == 0) { nCycle = nCycle + 1; }
	     var frequency1 = nCycle * fCalc / dataMax / timeX / nSample; // odd corrected frequency
	     frequency = nearestPrime(nCycle) * fCalc / dataMax / timeX / nSample; // prime corrected frequency	   
         infoX = infoX + " is mapped to " + valueToUnit(frequency1) 
	           + " prime " + valueToUnit(frequency) + " <br>\n"
			   + " Cycles " + nCycle + "<br> Np: " + nearestPrime(nCycle) + " fCalc: " + fCalc
			   + " dataMax: " + dataMax + " timeX: " + timeX + " nSample: " + nSample
			   + " timeBase: " + timeBase;
	   }
	   // end correct step size
	   step = Math.trunc(1024 * 1024 * 8 / fCalc * nSample * frequency) ;
</pre>

<h2>Triangle Waveform</h2><br>

<h3>Simulation</h3><br>

Input: start, stop, frequency, tsDAC<br>
Output: step, repeat<br>
<br>
Client side "T" command (NEEBench.html)<br>
<pre>
  step = (stop - start) / ( Tsignal / 2 / tsDAC) = (stop - start) * frequency * 2 * tsDAC<br>
</pre>
As step approaches small values &lt; 256 the frequency error will be large.<br>
A repeat value larger than 1 can make the error smaller.<br>
Since normally the tsDAC is smaller than the tsADC bigger repeat values are possible.<br>
The repeat value can be calculated by<br>
<pre>
  repeat = 1;
  // Coarseness 16
  var coarse = 16;
  if (step &lt; coarse) { repeat =  Math.round(coarse / step); }		 
  step = Math.round(step * repeat);
  repeat =  Math.round(256 / step);
</pre>

Server Side (ServerEEBench.js)<br>
<pre>
   var deltaX = (stopT - startT);
   for (var i = 0; i &lt; blockSize; i ++) {
     for (var j = 0; j &lt; mulTime * ratio; j ++) {   // take into account ratio=tsADC/tsDAC
       var posY = (stepT * Math.trunc( 1 / 16 *(i * mulTime * ratio + j) / repeatT) % (deltaX * 2); // limit to 2 * deltaX
       if (posY > deltaX) { posY = 2 * deltaX - posY; }           // rising or falling
       if ( deltaX == stepT) { // pulse
         posY = (Math.trunc( (i * mulTime * ratio + j) / 8 / repeatT) % 2) * deltaX; // factor 8 ??
       }
       posY = Math.round(startT + posY);
     }
   }
</pre>

<h3>Arduino</h3><br>

Client side same as simulation.<br>
Arduino EEBench.ino where ADC sample rate same as DAC sample rate<br>
<pre>
 // Generate Analog value Triangle
     int deltaX = (stopT - startT);
     int posY = ((int)(stepT) * (stepIndex / repeatT) ) % ( deltaX * 2); 
     if (posY > deltaX) posY = 2 * deltaX - posY;
     if ( deltaX == stepT){                            // Pulse
      posY = ((stepIndex * 2 / repeatT) % 2) * deltaX;
     }
     awgY = (int)(startT) + posY; // startT plus posY 
</pre>

<h2>Staircase</h2><br>

<h3>NodeEEBench.html</h3><br>

Same for all configurations.<br>
There seems to be room for improvement refactoring of the code with triangle.<br>
<pre>
if (curveTyp == 4) {  // Stair   
	   cmd = "T"; // triangle 
	   start = Math.trunc(maxC / maxV * (off-amp));
	   stop = Math.trunc(maxC / maxV * (off+amp));
	   if (start < 0) start = 0;
	   if (stop > maxC) stop = maxC;
	   repeat = Math.trunc(1 / frequency / 2 * fCalc / 5);    // 1E8 fFPGA 
       if (repeat == 0) { 
	      repeat = 1;      // ??	   
	   } else {	   
	      step = Math.trunc((stop-start)/5);
		  stop = Math.trunc((stop-start)/step)*step + start;
	   }	 
</pre>



<hr>
<h2>Test</h2><br>

To ensure correct operation and correct modifications a 'Test Flow' option was implemented in the system.<br>
Connecting the DAC outout to the ADC input relative errors regarding range and time can be detected.<br>
External measurement of voltages and frequency during the test flow with an Electronic Explorer board
ensures absolute error detection.<br> 
Each hardware has a specific test flow to cover frequency and voltage range.<br>
Here full testflows are given and results of test runs with typical errors are listed.<br>

<h3>Test BASYS3 FPGA</h3>

<br>
Number of samples: (256 of 512),(1024 of 2048), (4096 of 8192)<br>
Frequency range with a maximum ADC sampling frequency of 8.32us (120 kHz) and 
a maximum wait time of 1 s for a minimum frequency of 1 Hz.<br> 
Frequencies: 100 kHz (10 us), 10 kHz (100 us), 1 kHz (1 ms), 100 Hz (10 ms), 10 Hz (100 ms), 1 Hz (1 s)<br>
The time base should display the following cycles: 1, 11, 111, 1001, 10001, 100k<br>  
<br>

<span onclick="toggleViewX('24072025');"> 
<h3>24.07.2025 Manual test of sine, triangle and staircase showing AWG: f3dB = 30kHz low pass and FFT 
    bleeding</h3> </span>
<div id="24072025" style="display:none"><br>
24.07.2025: Test OSC, (256 of 512), 20ms/div, AWG, sine, 20 Hz, Amplitude 0.4V, Offset 0.5 V, Run<br>
24.07.2025: Test EE, frequency, measurement, AWG, frequency, 10 Hz, 20 Hz, 50 Hz, 100 Hz, 500 Hz, 1 Hz<br>
24.07.2025: Test AWG, pulse, triangle, stair, 20 Hz, 50 Hz, 100 Hz <br>
<br>
24.07.2025: At low frequencies FFT shows some bleeding. Adding +1, -1 to step size makes it worse.<br>
Frequencies: 1 MHz to 500 Hz shows f3dB = 30 kHz low pass for 16-Bit R2R with MCP6022 rail-to-rail OpAmp.<br>
Triangle and staircase were verified with the Electronic Explorer.<br>
</div>

<br> 

<h3>Test Arduino</h3>

Frequencies above 500Hz will be subsampled.<br>
21.08.2025 AWG Sine 20 Hz, offset = 0.5 V, amp = 0.4 V; 10ms/div, 20ms/div ok<br> 
FFT 20Hz, 100Hz, AWG1 -11 dB, -73 dB, C1 -11 dB -60 dB, C2 -8.5 dB -45 dB, C3 -11 dB -63 dB, C4 -8.47 dB -45.16 dB<br>
21.08.2025 AWG Sine, pulse, triangle, stair ok<br>

<h3>Test Simulation</h3><br>

20.08.2025 Sine 20 Hz, offset = 0.5 V, amp = 0.4 V; 10ms/div, 30 Hz, SL = -10.97 dB, NL = -91.44 dB<br>
Sine, 100 Hz, 2ms/div, ok, 10 kHz, fsample = 1 MHz, above subsampling<br>
Pulse, AWG = 100 kHz, OSC = 10us/div, OSC = 62.5 kHz; 5 kHz, 50 us/div, OSC=5.2 kHz; AWG = 1 kHz; OSC = 1 kHz;<br>
Staircase ok<br>  
06.08.2025 Sine with FFT, Pulse, triangle stairs are working<br>
03.08.2025 General Test: Sine frequency not ok and FFT frequency not ok<br>

<h3>General Test</h3><br>

The following code can be loaded into the 'Test Flow' tab and selects first an
AWG sine waveform with avg=0.5V, amp=0.4V, frequency=40Hz.<br>
AWG1 and C1 are measured with a time base of 5 ms/div.<br>
The frequency is changed to 100 Hz and 300Hz and time base is changed to 1 ms/div.<br>
FFT of AWG1 and C1 is checked with the total FFT table and individual values.<br>

<pre>
_tabAct=1; AWG tab activation
_setWave=1; AWG1; select Sine
#amplitudeVal=0.4 V; AWG1; set Amplitude
#offset1Val=0.5 V; AWG1; set Offset 
;sloop #baseval=('5 ms/div','200 us/div'); OSC; Time Base
#baseVal=5 ms/div, OSC, set Time Base
;floop #frequencyVal=('40 Hz','500 Hz'); AWG1; Frequency 
#frequencyVal=40 Hz; AWG1; Frequency ======Sine======================
_tabAct=1; AWG1 tab
_aOp=Run; AWG1; Run (continous)
_tabAct=2; OSC tab
_oOp=Run; OSC; Run (once)
-Measurement with 5 ms/div, avg=0.5V, amp=0.4V, frequency=40Hz&lt;br&gt; 
#oAWG1Avg; OSC; Measure; AWG1 average   
#oAWG1Amp; OSC; Measure; AWG1 amplitude   
#oAWG1f; OSC; Measure; AWG1 frequency   
- &lt;br&gt; 
#oC1Avg; OSC; Measure; C1 average   
#oC1Amp; OSC; Measure; C1 amplitude   
#oC1f; OSC; Measure; C1 frequency   
_oOp=Stop; OSC; Stop (once)
#frequencyVal=100 Hz; AWG1; Frequency ===================================
_aOp=Run; AWG1; Run (continous)
_oOp=Run; OSC; Run (once)
- &lt;br&gt; 
-Measurement: frequency=100Hz&lt;br&gt; 
#oAWG1f; OSC; Measure; AWG1 frequency   
- &lt;br&gt; 
_oOp=Stop; OSC; Stop (once)
#frequencyVal=300 Hz; AWG1; Frequency ===================================
_aOp=Run; AWG1; Run (continous)
_oOp=Run; OSC; Run (once)
-Measurement: frequency=300Hz&lt;br&gt; 
#oAWG1f; OSC; Measure; AWG1 frequency   
- &lt;br&gt; 
#baseVal=1 ms/div, OSC, Time Base =======================================
-Measurement: 1 ms/div, frequency=300Hz&lt;br&gt; 
#oAWG1f; OSC; Measure; AWG1 frequency   
- &lt;br&gt; 
_oOp=Stop; OSC; Stop (once)
_fOp=Run; FFT tab ==================================FFT AWG===============
#fftSrc=1; FFT select AWG1
_cHarm; FFT calculate Harmonics
#fftTable; FFT table
- Index: 
#fftIndex0; FFT Measure   
- Frequency:  
#fftfreq0; FFT Measure   
- Signal magnitude:  
#fftSM0; Signal magnitude FFT Measure   
- Noise magnitude: 
#fftNM0; FFT Noise magnitude Measure   
-&lt;br&gt;
#fftSrc=2; FFT select C1 ==========================FFT C1=================
_cHarm; FFT calculate Harmonics
#fftTable; FFT table
_tabAct=12; Test flow tab
_tOp=Stop; Test flow stop
;eloop
</pre>

 <br><hr>
 <br>
 <div id="footer" style="background-color:#0067a5;color:#FFFFFF">
<br>
 &nbsp; Hochschule f&uuml;r angewandte Wissenschaften Kempten, J&ouml;rg Vollrath, Bahnhofstra&szlig;e 61 &middot; 87435 Kempten<br>
 &nbsp; Tel. 0831/25 23-0 &middot; Fax 0831/25 23-104 &middot; E-Mail: joerg.vollrath(at)hs-kempten.de <br>
 <a href="http://www.hochschule-kempten.de/metanavigation/impressum.html"> 
  <div style="background-color:#0067a5;color:#FFFFFF"> Impressum </div> </a>
 </div>
       <script type="text/javascript"> 
<!-- Begin
	   function toggleViewX(obName) {
	     // alert(obName);
	     if (document.getElementById(obName).style.display == "block") {
		   document.getElementById(obName).style.display = "none";
		 } else {
		   document.getElementById(obName).style.display = "block";
		 }
	   }


 //  End -->
	  </script>
 </body>
</html>
